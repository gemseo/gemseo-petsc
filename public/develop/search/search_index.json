{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#gemseo-petsc","title":"gemseo-petsc","text":""},{"location":"#overview","title":"Overview","text":"<p>PETSc GEMSEO interface.</p> <p>This plugin provides an interface to the PETSc linear solvers and Ordinary Differential Equations (ODE) solvers. Linear solvers can be used for direct and adjoint linear system resolution in GEMSEO. The ODE solver provides the computation of the adjoints with respect to the initial conditions of the ODE and with respect to the design variables.</p>"},{"location":"#installation","title":"Installation","text":"<p>gemseo-petsc relies on petsc4py, the Python bindings for PETSc. PETSc and petsc4py are available on pypi, but no wheel are available. Hence, depending on the initial situation, here are our recommendations:</p>"},{"location":"#linux-environment","title":"Linux environment","text":""},{"location":"#using-conda","title":"Using Conda","text":"<p>PETSc and petsc4py are available on the conda-forge repository. If you start from scratch of if you want to install the plugin in a pre-existing conda environment, you can use the following command in your current conda environment before installing gemseo-petsc:</p> <pre><code>conda install -c conda-forge petsc4py\n</code></pre>"},{"location":"#using-pip","title":"Using pip","text":"<p>PETSc and petsc4py can be build from their sources by using pip. To do so, use the following commands in your Python environment.</p> <pre><code>pip install petsc petsc4py\n</code></pre>"},{"location":"#by-building-petsc-and-petsc4py-from-sources","title":"By building PETSc and petsc4py from sources","text":"<p>It is also possible to build PETSc and petsc4py from the PETSc sources. To do so, please follow the information provided in the PETSc installation manual, and do not forget to enable the compilation of petsc4py.</p> <p>Although it has not be tested, it is possible to build PETSc and petsc4py under a Windows environment, and hence to have the gemseo-petsc plugin working. A description of the procedure to build these dependencies can be found here</p>"},{"location":"#bugs-and-questions","title":"Bugs and questions","text":"<p>Please use the gitlab issue tracker to submit bugs or questions.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>See the contributing section of GEMSEO.</p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Fran\u00e7ois Gallard</li> <li>Jean-Christophe Giret</li> <li>Antoine Dechaume</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes of this project will be documented here.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#version-410-march-2025","title":"Version 4.1.0 (March 2025)","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Implementation of the interface between PETSc.TS and Gemseo for the solution of Ordinary Differential Equations and computation of the adjoint.</li> </ul>"},{"location":"changelog/#version-400-november-2024","title":"Version 4.0.0 (November 2024)","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Support GEMSEO v6.</li> <li>Support for Python 3.12.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Renamed <code>ksp_library.py</code> to <code>petsc_ksp.py</code></li> <li>Switched from JSON schema to Pydantic model for options validation.</li> <li>Each solver now has a dedicated GEMSEO algo, named <code>PETSC_...</code>. This replaces the   <code>solver_type</code> option.</li> </ul>"},{"location":"changelog/#version-301-december-2023","title":"Version 3.0.1 (December 2023)","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for Python 3.11.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Support for Python 3.8.</li> </ul>"},{"location":"changelog/#version-300-june-2023","title":"Version 3.0.0 (June 2023)","text":"<p>Update to GEMSEO 5.0.0.</p>"},{"location":"changelog/#changed_1","title":"Changed","text":"<p>Renamed <code>ksp_lib.py</code> to <code>ksp_library.py</code>.</p>"},{"location":"changelog/#version-200-november-2021","title":"Version 2.0.0 (November 2021)","text":"<p>Update to GEMSEO 4.0.0.</p>"},{"location":"changelog/#version-100-november-2021","title":"Version 1.0.0 (November 2021)","text":"<p>First release.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-1--credits","title":"Credits","text":"<p>The developers thank all the open source libraries making <code>gemseo-petsc</code> possible.</p>"},{"location":"credits/#exec-1--external-dependencies","title":"External Dependencies","text":"<p><code>gemseo-petsc</code> depends on software with compatible licenses that are listed below.</p> Project License <code>Python</code> Python Software License <code>gemseo</code> GNU Lesser General Public License v3 <code>numpy</code> BSD License <code>petsc4py</code> BSD-2-Clause <code>scipy</code> BSD License"},{"location":"credits/#exec-1--external-applications","title":"External applications","text":"<p>Some external applications are used by <code>gemseo-petsc</code>, but not linked with the application, for testing, documentation generation, training or example purposes.</p> Project License <code>black</code> MIT License <code>commitizen</code> MIT License <code>covdefaults</code> MIT License <code>griffe-inherited-docstrings</code> ISC <code>insert-license</code> MIT <code>markdown-exec</code> ? <code>mike</code> BSD-3-Clause <code>mkdocs-bibtex</code> BSD-3-Clause-LBNL <code>mkdocs-gallery</code> BSD 3-Clause <code>mkdocs-gen-files</code> MIT License <code>mkdocs-include-markdown-plugin</code> Apache Software License <code>mkdocs-literate-nav</code> MIT License <code>mkdocs-material</code> MIT License <code>mkdocs-section-index</code> MIT License <code>mkdocstrings</code> ? <code>pre-commit</code> MIT License <code>pygrep-hooks</code> MIT <code>pytest</code> MIT License <code>pytest-cov</code> MIT License <code>pytest-xdist</code> MIT License <code>ruff</code> MIT License <code>setuptools</code> ? <code>setuptools-scm</code> MIT License"},{"location":"licenses/","title":"Licenses","text":""},{"location":"licenses/#licenses","title":"Licenses","text":""},{"location":"licenses/#gnu-lgpl-v30","title":"GNU LGPL v3.0","text":"<p>The <code>gemseo-petsc</code> source code is distributed under the GNU LGPL v3.0 license. <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis program is free software; you can redistribute it and/or\nmodify it under the terms of the GNU Lesser General Public\nLicense version 3 as published by the Free Software Foundation.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nLesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with this program; if not, write to the Free Software Foundation,\nInc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n</code></pre></p>"},{"location":"licenses/#bsd-0-clause","title":"BSD 0-Clause","text":"<p>The <code>gemseo-petsc</code> examples are distributed under the BSD 0-Clause <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis work is licensed under a BSD 0-Clause License.\n\nPermission to use, copy, modify, and/or distribute this software\nfor any purpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL\nTHE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT,\nOR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\nFROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\nWITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre></p>"},{"location":"licenses/#cc-by-sa-40","title":"CC BY-SA 4.0","text":"<p>The <code>gemseo-petsc</code> documentation is distributed under the CC BY-SA 4.0 license. <pre><code>Copyright 2021 IRT Saint Exup\u00e9ry, https://www.irt-saintexupery.com\n\nThis work is licensed under the Creative Commons Attribution-ShareAlike 4.0\nInternational License. To view a copy of this license, visit\nhttp://creativecommons.org/licenses/by-sa/4.0/ or send a letter to Creative\nCommons, PO Box 1866, Mountain View, CA 94042, USA.\n</code></pre></p>"},{"location":"generated/examples/smooth_ode/","title":"Solution of an ODE","text":""},{"location":"generated/examples/smooth_ode/#ordinary-differential-equations","title":"Ordinary Differential Equations","text":"<p> Solve an Initial Value Problem </p> <p> Compute the Jacobian of the solution of an ODE </p> <p> Download all examples in Python source code: smooth_ode_python.zip</p> <p> Download all examples in Jupyter notebooks: smooth_ode_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/smooth_ode/mg_execution_times/","title":"Computation times","text":"<p>00:04.728 total execution time for generated_examples_smooth_ode files:</p> <p>+---------------------------------------------------------------------------------------------+-----------+--------+ | plot_smooth_ode (docs/examples/smooth_ode/plot_smooth_ode.py)       | 00:04.723 | 0.0 MB | +---------------------------------------------------------------------------------------------+-----------+--------+ | plot_jacobian_ode (docs/examples/smooth_ode/plot_jacobian_ode.py) | 00:00.005 | 0.0 MB | +---------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated/examples/smooth_ode/plot_jacobian_ode/","title":"Compute the Jacobian of the solution of an ODE","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/smooth_ode/plot_jacobian_ode/#compute-the-jacobian-of-the-solution-of-an-ode","title":"Compute the Jacobian of the solution of an ODE","text":"<p>Let us consider an Initial Value Problem (IVP), consisting of an Ordinary Differential Equation (ODE), potentially depending on a set of design variables, a time interval, and a set of initial conditions for the state of the system.</p> <p>We are interested in computing the sensitivity of the solution with respect to the initial conditions and eventual design variables present in the expression of the ODE.</p> <pre><code>from gemseo.algos.ode.factory import ODESolverLibraryFactory\nfrom gemseo.algos.ode.ode_problem import ODEProblem\nfrom gemseo.typing import RealArray\nfrom numpy import atleast_1d\nfrom numpy import linspace\nfrom numpy import zeros\n</code></pre> <p>Let us consider the same IVP presented in the example about the Solution of an Initial Value Problem:</p> \\[     \\frac{dy(t)}{dt} = k t y^2 \\] <p>where \\(t\\) denotes the time, \\(y\\) is the state variable, and \\(k\\) is a design parameter.</p> <pre><code>init_state = 1.0\nfinal_time = 0.5\ntimes = linspace(0.0, final_time, 51)\nk = 1.0\n</code></pre> <p>The function defining the dynamics of the ODE is the following:</p> <pre><code>def rhs_func(t: float, y: RealArray, k: float) -&gt; RealArray:\n    st_dot = y.copy()\n    st_dot[0] = k * t * y[0] ** 2\n    return st_dot\n</code></pre> <p>We provide the Jacobian of the dynamics with respect to the state and to the design variables.</p> <pre><code>def compute_jac_wrt_state(\n    t: float,\n    y: RealArray,\n    k: float,\n) -&gt; RealArray:\n    return k * 2 * t * y[0]\n\n\ndef compute_jac_wrt_desvar(\n    t: float,\n    y: RealArray,\n    k: float,\n) -&gt; RealArray:\n    return t * y[0] ** 2\n</code></pre> <p>These functions are assembled into an ODEProblem.</p> <pre><code>class SmoothODEProblem(ODEProblem):\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.__jac_wrt_state = zeros((1, 1))\n        self.__k = k\n        super().__init__(\n            self.__compute_rhs_func,\n            jac_function_wrt_state=self.__compute_jac_wrt_state,\n            jac_function_wrt_desvar=self.__compute_jac_wrt_desvar,\n            initial_state=atleast_1d(init_state),\n            times=times,\n        )\n\n        self.__jac_wrt_desvar = zeros((1, 1))\n\n    def __compute_rhs_func(self, time, state):\n        return rhs_func(time, state, self.__k)\n\n    def __compute_jac_wrt_state(self, time, state):\n        self.__jac_wrt_state[0, 0] = compute_jac_wrt_state(time, state, self.__k)\n        return self.__jac_wrt_state\n\n    def __compute_jac_wrt_desvar(self, time, state):\n        self.__jac_wrt_desvar[0, 0] = compute_jac_wrt_desvar(time, state, self.__k)\n        return self.__jac_wrt_desvar\n\n\nproblem = SmoothODEProblem()\n</code></pre> <p>By setting the parameter <code>compute_adjoint</code> to <code>True</code> in <code>ODESolverLibraryFactory().execute()</code>, the PETSc solver computes the sensitivity of the solution of the ODE with respect to the initial conditions of the IVP and to the design variables by solving a suitable adjoint problem.</p> <p>In order to solve the adjoint problem backwards in time, PETSc stores some intermediary values of the state under a checkpoint system. The checkpoints can be stored either on disk or on RAM. The storage of checkpoints on the RAM can be enabled by setting the optional parameter <code>use_memory_checkpoints</code> to <code>True</code>. The maximal number of checkpoints to be stored on disk or on the RAM can be controlled by the optional parameters <code>max_disk_checkpoints</code> and <code>max_memory_checkpoints</code>.</p> <pre><code>ODESolverLibraryFactory().execute(\n    problem,\n    algo_name=\"PETSC_ODE_RK\",\n    time_step=1e-2,\n    maximum_steps=1000,\n    rtol=1e-3,\n    use_jacobian=True,\n    compute_adjoint=True,\n    use_memory_checkpoints=True,\n)\n</code></pre> <p>Out:</p> <pre><code>TS rejected steps SNES : 1\n</code></pre> <p>The Jacobian of the solution of the IVP with respect to the initial conditions and the design variables can be found respectively in the attributes <code>jac_wrt_initial_state</code> and <code>jac_wrt_desvar</code> of <code>problem.result</code>.</p> <p>The Jacobians computed by PETSc can be compared with their analytical counterparts. By knowing that the exact solution of the IVP is \\(y(t) = \\frac{ 2 y_0}{2 - k t^2 y_0}\\), the Jacobians of the solution with respect to \\(y_0\\) and \\(k\\) are:</p> \\[ J_{y_0} = \\left[\\frac{4}{(2 - k t^2 y_0)^2}\\right] \\] \\[ J_{k} = \\left[\\frac{2 y_0^2 t^2}{(2 - k t^2 y_0)^2}\\right] \\] <pre><code>analytical_jac_initial_state = 4.0 / (2 - k * final_time**2 * init_state) ** 2\nanalytical_jac_desvar = (\n    2 * init_state**2 * final_time**2 / (2 - k * final_time**2 * init_state) ** 2\n)\n\nerror_jac_initial_state = abs(\n    analytical_jac_initial_state - problem.result.jac_wrt_initial_state[0, 0]\n)\n\nerror_jac_desvar = abs(analytical_jac_desvar - problem.result.jac_wrt_desvar[0, 0])\n\nprint(\n    f\"Jacobian with respect to the initial state: \\n\"\n    f\"     absolute error = {error_jac_initial_state}, \"\n    f\"     relative error = {error_jac_initial_state / analytical_jac_initial_state}\"\n)\n\nprint(\n    f\"Jacobian with respect to the design variable: \\n\"\n    f\"     absolute error = {error_jac_desvar}, \"\n    f\"     relative error = {error_jac_desvar / analytical_jac_desvar}\"\n)\n</code></pre> <p>Out:</p> <pre><code>Jacobian with respect to the initial state: \n     absolute error = 0.00042108898775672365,      relative error = 0.00032239625625124155\nJacobian with respect to the design variable: \n     absolute error = 0.00032624203083669867,      relative error = 0.0019982324388747794\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.005 seconds)</p> <p> Download Python source code: plot_jacobian_ode.py</p> <p> Download Jupyter notebook: plot_jacobian_ode.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated/examples/smooth_ode/plot_smooth_ode/","title":"Solve an Initial Value Problem","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated/examples/smooth_ode/plot_smooth_ode/#solve-an-initial-value-problem","title":"Solve an Initial Value Problem","text":"<p>Let us consider an Initial Value Problem (IVP), consisting of an Ordinary Differential Equation (ODE), potentially depending on a set of design variables, a time interval, and a set of initial conditions for the state of the system.</p> <pre><code>from gemseo.algos.ode.factory import ODESolverLibraryFactory\nfrom gemseo.algos.ode.ode_problem import ODEProblem\nfrom gemseo.typing import RealArray\nfrom matplotlib import pyplot as plt\nfrom numpy import array\nfrom numpy import atleast_1d\nfrom numpy import linspace\nfrom numpy import zeros\n</code></pre> <p>Out:</p> <pre><code>/builds/gemseo/dev/gemseo-petsc/src/gemseo_petsc/linear_solvers/petsc_ksp.py:41: DeprecationWarning: Please import `issparse` from the `scipy.sparse` namespace; the `scipy.sparse.base` namespace is deprecated and will be removed in SciPy 2.0.0.\n  from scipy.sparse.base import issparse\n/builds/gemseo/dev/gemseo-petsc/src/gemseo_petsc/utils/conversion.py:32: DeprecationWarning: Please import `issparse` from the `scipy.sparse` namespace; the `scipy.sparse.base` namespace is deprecated and will be removed in SciPy 2.0.0.\n  from scipy.sparse.base import issparse\n&lt;frozen importlib._bootstrap&gt;:228: DeprecationWarning: builtin type SwigPyPacked has no __module__ attribute\n&lt;frozen importlib._bootstrap&gt;:228: DeprecationWarning: builtin type SwigPyObject has no __module__ attribute\n&lt;frozen importlib._bootstrap&gt;:228: DeprecationWarning: builtin type swigvarlink has no __module__ attribute\n</code></pre> <p>Let us consider the following IVP:</p> \\[     \\frac{dy(t)}{dt} = k t y^2 \\] <p>where \\(t\\) denotes the time, \\(y\\) is the state variable, and \\(k\\) is a design parameter.</p> <p>We define an initial state and a time interval for the IVP, as well as a design parameter \\(k\\).</p> <pre><code>init_state = 1.0\ntimes = linspace(0.0, 0.5, 51)\nk = 1.0\n</code></pre> <p>The function defining the dynamics of the ODE is the following:</p> <pre><code>def rhs_func(t: float, y: RealArray, k: float) -&gt; RealArray:\n    st_dot = y.copy()\n    st_dot[0] = k * t * y[0] ** 2\n    return st_dot\n</code></pre> <p>We define the Jacobian of the dynamics with respect to the state.</p> <pre><code>def compute_jac_wrt_state(\n    t: float,\n    y: RealArray,\n    k: float,\n) -&gt; RealArray:\n    jac_wrt_state = k * 2 * t * y[0]\n    return array([[jac_wrt_state]])\n</code></pre> <p>These functions are assembled into an ODEProblem.</p> <pre><code>class SmoothODEProblem(ODEProblem):\n    def __init__(self) -&gt; None:  # noqa: D107\n        self.__jac_wrt_state = zeros((1, 1))\n        self.__k = k\n        super().__init__(\n            self.__compute_rhs_func,\n            jac_function_wrt_state=self.__compute_jac_wrt_state,\n            initial_state=atleast_1d(init_state),\n            times=times,\n        )\n\n        self.__jac_wrt_desvar = zeros((1, 1))\n\n    def __compute_rhs_func(self, time, state):\n        return rhs_func(time, state, self.__k)\n\n    def __compute_jac_wrt_state(self, time, state):\n        self.__jac_wrt_state[0, 0] = compute_jac_wrt_state(time, state, self.__k)\n        return self.__jac_wrt_state\n\n\nproblem = SmoothODEProblem()\n</code></pre> <p>The IVP can be solved using the algorithms provided by <code>gemseo-petsc</code>. As an example, here the solution to the IVP is found using the Runge-Kutta algorithm.</p> <pre><code>ODESolverLibraryFactory().execute(\n    problem,\n    algo_name=\"PETSC_ODE_RK\",\n    time_step=1e-2,\n    maximum_steps=1000,\n    rtol=1e-3,\n    use_jacobian=True,\n)\n</code></pre> <p>Out:</p> <pre><code>TS rejected steps SNES : 1\n</code></pre> <p>The numerical solution can be compared with the analytical solution of the ODE.</p> \\[     y(t) = \\frac{ 2 y_0}{2 - k t^2 y_0}. \\] <pre><code>analytical_sol = 2.0 * init_state / (2.0 - k * times * times * init_state)\nerror = abs(analytical_sol - problem.result.state_trajectories[0])\n\nplt.semilogy(times, error)\nplt.title(\"Integration error\")\nplt.show()\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  4.723 seconds)</p> <p> Download Python source code: plot_smooth_ode.py</p> <p> Download Jupyter notebook: plot_smooth_ode.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>gemseo_petsc<ul> <li>linear_solvers<ul> <li>petsc_ksp</li> <li>settings<ul> <li>petsc_ksp_settings</li> </ul> </li> </ul> </li> <li>ode<ul> <li>settings<ul> <li>petsc_ts_settings</li> </ul> </li> <li>ts_library</li> </ul> </li> <li>problems<ul> <li>smooth_ode</li> <li>vanderpol</li> </ul> </li> <li>utils<ul> <li>conversion</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/gemseo_petsc/","title":"API documentation","text":""},{"location":"reference/gemseo_petsc/#gemseo_petsc","title":"gemseo_petsc","text":"<p>This package contains the PETSc GEMSEO interface.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/","title":"Linear solvers","text":""},{"location":"reference/gemseo_petsc/linear_solvers/#gemseo_petsc.linear_solvers","title":"linear_solvers","text":"<p>This package contains the PETSc linear solver.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/","title":"Petsc ksp","text":""},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp","title":"petsc_ksp","text":"<p>A PETSC KSP linear solvers library wrapper.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp-classes","title":"Classes","text":""},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp.PetscKSP","title":"PetscKSP","text":"<p>               Bases: <code>BaseLinearSolverLibrary</code></p> <p>Interface to PETSC KSP.</p> <p>For further information, please read [https://petsc4py.readthedocs.io/en/stable/manual/ksp/] and https://petsc.org/release/docs/manualpages/KSP/KSP.html#KSP].</p>"},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp.PetscKSPAlgorithmDescription","title":"PetscKSPAlgorithmDescription  <code>dataclass</code>","text":"<pre><code>PetscKSPAlgorithmDescription(\n    library_name: str = \"PETSc KSP\",\n    lhs_must_be_linear_operator: bool = True,\n)\n</code></pre> <p>               Bases: <code>LinearSolverDescription</code></p> <p>The description of the PETSc KSP linear algebra library.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp.PetscKSPAlgorithmDescription-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp.PetscKSPAlgorithmDescription.lhs_must_be_linear_operator","title":"lhs_must_be_linear_operator  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs_must_be_linear_operator: bool = True\n</code></pre> <p>Whether the left-hand side matrix must be a linear operator.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/petsc_ksp/#gemseo_petsc.linear_solvers.petsc_ksp.PetscKSPAlgorithmDescription.library_name","title":"library_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>library_name: str = 'PETSc KSP'\n</code></pre> <p>The library name.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/settings/","title":"Settings","text":""},{"location":"reference/gemseo_petsc/linear_solvers/settings/#gemseo_petsc.linear_solvers.settings","title":"settings","text":"<p>The settings of PETSc KSP linear algebra library algorithms.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/settings/petsc_ksp_settings/","title":"Petsc ksp settings","text":""},{"location":"reference/gemseo_petsc/linear_solvers/settings/petsc_ksp_settings/#gemseo_petsc.linear_solvers.settings.petsc_ksp_settings","title":"petsc_ksp_settings","text":"<p>Settings for the PETSc KSP linear solvers.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/settings/petsc_ksp_settings/#gemseo_petsc.linear_solvers.settings.petsc_ksp_settings-classes","title":"Classes","text":""},{"location":"reference/gemseo_petsc/linear_solvers/settings/petsc_ksp_settings/#gemseo_petsc.linear_solvers.settings.petsc_ksp_settings.BasePetscKSPSettings","title":"BasePetscKSPSettings","text":"<p>               Bases: <code>BaseLinearSolverSettings</code></p> <p>The base settings of the PETSc KSP algorithms.</p> <p><code>_TARGET_CLASS_NAME</code> will be overloaded for each algorithm.</p>"},{"location":"reference/gemseo_petsc/linear_solvers/settings/petsc_ksp_settings/#gemseo_petsc.linear_solvers.settings.petsc_ksp_settings.PreconditionerType","title":"PreconditionerType","text":"<p>               Bases: <code>StrEnum</code></p> <p>The type of the precondtioner.</p> <p>See [https://www.mcs.anl.gov/petsc/petsc4py-current/docs/apiref/petsc4py.PETSc.PC.Type-class.html].</p>"},{"location":"reference/gemseo_petsc/ode/","title":"Ode","text":""},{"location":"reference/gemseo_petsc/ode/#gemseo_petsc.ode","title":"ode","text":"<p>This package contains the PETSc ordinary differential equation solver.</p>"},{"location":"reference/gemseo_petsc/ode/ts_library/","title":"Ts library","text":""},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library","title":"ts_library","text":"<p>A wrapper for the PETSc ODE solvers.</p> <p>ODE stands for ordinary differential equation.</p>"},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library-classes","title":"Classes","text":""},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscOdeAlgo","title":"PetscOdeAlgo","text":"<pre><code>PetscOdeAlgo(algo_name: str)\n</code></pre> <p>               Bases: <code>BaseODESolverLibrary</code></p> <p>Interface to PETSC TS.</p> <p>For further information, please read https://petsc.org/release/docs/manual/ts/ For a list of available methods, see https://petsc.org/release/overview/integrator_table/#integrator-table</p> <p>For the unsteady adjoint part: https://petsc4py.readthedocs.io/en/stable/manual/sensitivity_analysis/</p> <p>About checkpoints: https://petsc4py.readthedocs.io/en/stable/manual/sensitivity_analysis/#checkpointing</p> <p>Parameters:</p> <ul> <li> <code>algo_name</code>               (<code>str</code>)           \u2013            <p>The name of the algorithm solving the ODE.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>When the algorithm is not in the library.</p> </li> </ul> Source code in <code>src/gemseo_petsc/ode/ts_library.py</code> <pre><code>def __init__(self, algo_name: str) -&gt; None:  # noqa: D107\n    \"\"\"\n    Args:\n        algo_name: The name of the algorithm solving the ODE.\n    \"\"\"  # noqa: D205, D212, D415\n    super().__init__(algo_name=algo_name)\n    self.__rhs_indices = []\n    # adjoint_wrt_state is adjoint for cost gradient wrt y at t0 (initial condition)\n    # FG: this seems to be df(t=O)/d(y(t=0))\n    # adjoint_wrt_desvar is adjoint for cost gradient wrt scalar parameter mu\n    # FG: this seems to be df(t=O)/dx\n    # Initialize them with cost function derivatives wrt u and mu (resp.) at t=tF\n    self.adjoint_wrt_state = []\n    self.adjoint_wrt_desvar = []\n    # Save ODE history\n    self._hist_iterations, self._hist_times, self._hist_state = [], [], []\n    self.__n_calls_jac = 0\n</code></pre>"},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscOdeAlgo-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscOdeAlgo.adjoint_wrt_desvar","title":"adjoint_wrt_desvar  <code>instance-attribute</code>","text":"<pre><code>adjoint_wrt_desvar: list[Vec] = []\n</code></pre> <p>The adjoint with respect to the design parameters.</p>"},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscOdeAlgo.adjoint_wrt_state","title":"adjoint_wrt_state  <code>instance-attribute</code>","text":"<pre><code>adjoint_wrt_state: list[Vec] = []\n</code></pre> <p>The adjoint with respect to the state.</p>"},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscTSAlgorithmDescription","title":"PetscTSAlgorithmDescription  <code>dataclass</code>","text":"<pre><code>PetscTSAlgorithmDescription(\n    Settings: type[BaseODESolverSettings] = PetscTSSettings,\n)\n</code></pre> <p>               Bases: <code>ODESolverDescription</code></p> <p>The description of the PETSc TS ODE library.</p>"},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscTSAlgorithmDescription-attributes","title":"Attributes","text":""},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library.PetscTSAlgorithmDescription.Settings","title":"Settings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Settings: type[BaseODESolverSettings] = PetscTSSettings\n</code></pre> <p>The settings validation model.</p>"},{"location":"reference/gemseo_petsc/ode/ts_library/#gemseo_petsc.ode.ts_library-functions","title":"Functions","text":""},{"location":"reference/gemseo_petsc/ode/settings/","title":"Settings","text":""},{"location":"reference/gemseo_petsc/ode/settings/#gemseo_petsc.ode.settings","title":"settings","text":"<p>The settings of PETSc ordinary differential equation solver.</p>"},{"location":"reference/gemseo_petsc/ode/settings/petsc_ts_settings/","title":"Petsc ts settings","text":""},{"location":"reference/gemseo_petsc/ode/settings/petsc_ts_settings/#gemseo_petsc.ode.settings.petsc_ts_settings","title":"petsc_ts_settings","text":"<p>Settings for the PETSc ordinary differential equation solver. solvers.</p>"},{"location":"reference/gemseo_petsc/ode/settings/petsc_ts_settings/#gemseo_petsc.ode.settings.petsc_ts_settings-classes","title":"Classes","text":""},{"location":"reference/gemseo_petsc/ode/settings/petsc_ts_settings/#gemseo_petsc.ode.settings.petsc_ts_settings.FinalTimeBehavior","title":"FinalTimeBehavior","text":"<p>               Bases: <code>StrEnum</code></p> <p>The behavior at the end of the resolution.</p>"},{"location":"reference/gemseo_petsc/ode/settings/petsc_ts_settings/#gemseo_petsc.ode.settings.petsc_ts_settings.ODESolverType","title":"ODESolverType","text":"<p>               Bases: <code>StrEnum</code></p> <p>The type of ODE Solver.</p> <p>See [https://www.mcs.anl.gov/petsc/petsc4py-current/docs/apiref/petsc4py.PETSc.PC.Type-class.html].</p>"},{"location":"reference/gemseo_petsc/ode/settings/petsc_ts_settings/#gemseo_petsc.ode.settings.petsc_ts_settings.PetscTSSettings","title":"PetscTSSettings","text":"<p>               Bases: <code>BaseODESolverSettings</code></p> <p>The base settings of the PETSc TS algorithms.</p>"},{"location":"reference/gemseo_petsc/problems/","title":"Problems","text":""},{"location":"reference/gemseo_petsc/problems/#gemseo_petsc.problems","title":"problems","text":"<p>ODE problems with adjoint.</p>"},{"location":"reference/gemseo_petsc/problems/smooth_ode/","title":"Smooth ode","text":""},{"location":"reference/gemseo_petsc/problems/smooth_ode/#gemseo_petsc.problems.smooth_ode","title":"smooth_ode","text":"<p>A Smooth ODE dy/dt=k.t.y\u00b2.</p>"},{"location":"reference/gemseo_petsc/problems/smooth_ode/#gemseo_petsc.problems.smooth_ode-classes","title":"Classes","text":""},{"location":"reference/gemseo_petsc/problems/smooth_ode/#gemseo_petsc.problems.smooth_ode.SmoothODE","title":"SmoothODE","text":"<pre><code>SmoothODE(\n    initial_state: float = 1.0,\n    k: float = 1.0,\n    is_k_design_var: bool = False,\n)\n</code></pre> <p>               Bases: <code>ODEProblem</code></p> <p>Smooth ODE dy/dt = k.t.y\u00b2.</p> <p>Initialize state and ODE functions.</p> <p>Parameters:</p> <ul> <li> <code>initial_state</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The initial condition.</p> </li> <li> <code>k</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>A coefficient in the ODE.</p> </li> <li> <code>is_k_design_var</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, k becomes a design variable otherwise, there is no dependency to k in the gradient.</p> </li> </ul> Source code in <code>src/gemseo_petsc/problems/smooth_ode.py</code> <pre><code>def __init__(\n    self, initial_state: float = 1.0, k: float = 1.0, is_k_design_var: bool = False\n) -&gt; None:  # noqa: D107\n    \"\"\"Initialize state and ODE functions.\n\n    Args:\n        initial_state: The initial condition.\n        k: A coefficient in the ODE.\n        is_k_design_var: If True, k becomes a design variable\n            otherwise, there is no dependency to k in the gradient.\n    \"\"\"\n    self.__jac_wrt_state = zeros((1, 1))\n    self.__k = k\n    super().__init__(\n        self.__compute_rhs_func,\n        jac_function_wrt_state=self.__compute_jac_wrt_state,\n        jac_function_wrt_desvar=self.__compute_jac_wrt_desvar\n        if is_k_design_var\n        else None,\n        initial_state=atleast_1d(initial_state),\n        times=linspace(0, 1.0, 100),\n    )\n\n    self.__jac_wrt_desvar = zeros((1, 1))\n</code></pre>"},{"location":"reference/gemseo_petsc/problems/vanderpol/","title":"Vanderpol","text":""},{"location":"reference/gemseo_petsc/problems/vanderpol/#gemseo_petsc.problems.vanderpol","title":"vanderpol","text":"<p>Van der Pol ODE.</p>"},{"location":"reference/gemseo_petsc/problems/vanderpol/#gemseo_petsc.problems.vanderpol-classes","title":"Classes","text":""},{"location":"reference/gemseo_petsc/problems/vanderpol/#gemseo_petsc.problems.vanderpol.VanderPol","title":"VanderPol","text":"<pre><code>VanderPol(\n    mu: float = 0.5,\n    final_time: float = 2.0,\n    n_pts_time_vector: int = 1000,\n)\n</code></pre> <p>               Bases: <code>ODEProblem</code></p> <p>Van der Pol ODE.</p> <p>Initialize state and ODE functions.</p> <p>Parameters:</p> <ul> <li> <code>mu</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The mu coefficient in the ODE</p> </li> <li> <code>final_time</code>               (<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>The final time of the ODE resolution.</p> </li> <li> <code>n_pts_time_vector</code>               (<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>The number of points in the time_vector.</p> </li> </ul> Source code in <code>src/gemseo_petsc/problems/vanderpol.py</code> <pre><code>def __init__(\n    self, mu: float = 0.5, final_time: float = 2.0, n_pts_time_vector: int = 1000\n) -&gt; None:  # noqa: D107\n    \"\"\"Initialize state and ODE functions.\n\n    Args:\n        mu: The mu coefficient in the ODE\n        final_time: The final time of the ODE resolution.\n        n_pts_time_vector: The number of points in the time_vector.\n    \"\"\"\n    self.__jac_wrt_state = zeros((2, 2))\n    self.__jac_wrt_desvar = zeros((2, 1))\n    self.__mu = mu\n    super().__init__(\n        self.__func,\n        initial_state=array([2.0, -2.0 / 3.0]),\n        times=linspace(0.0, final_time, n_pts_time_vector),\n        jac_function_wrt_state=self.__compute_jac_wrt_state,\n        jac_function_wrt_desvar=self.__compute_jac_wrt_desvar,\n    )\n</code></pre>"},{"location":"reference/gemseo_petsc/utils/","title":"Utils","text":""},{"location":"reference/gemseo_petsc/utils/#gemseo_petsc.utils","title":"utils","text":"<p>Utilities used by multiple sub-modules of the plugin.</p>"},{"location":"reference/gemseo_petsc/utils/conversion/","title":"Conversion","text":""},{"location":"reference/gemseo_petsc/utils/conversion/#gemseo_petsc.utils.conversion","title":"conversion","text":"<p>Conversion functions.</p> <p>Utilities for converting objects between those used by SciPy and those used by PETSc.</p>"},{"location":"reference/gemseo_petsc/utils/conversion/#gemseo_petsc.utils.conversion-functions","title":"Functions","text":""},{"location":"reference/gemseo_petsc/utils/conversion/#gemseo_petsc.utils.conversion.convert_ndarray_to_mat_or_vec","title":"convert_ndarray_to_mat_or_vec","text":"<pre><code>convert_ndarray_to_mat_or_vec(\n    np_arr: NDArray[float],\n) -&gt; Mat | Vec\n</code></pre> <p>Convert a Numpy array to a PETSc Mat or Vec.</p> <p>Parameters:</p> <ul> <li> <code>np_arr</code>               (<code>NDArray[float]</code>)           \u2013            <p>The input Numpy array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Mat | Vec</code>           \u2013            <p>A PETSc Mat or Vec, depending on the input dimension.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the dimension of the input vector is greater than 2.</p> </li> </ul> Source code in <code>src/gemseo_petsc/utils/conversion.py</code> <pre><code>def convert_ndarray_to_mat_or_vec(\n    np_arr: NDArray[float],\n) -&gt; PETSc.Mat | PETSc.Vec:\n    \"\"\"Convert a Numpy array to a PETSc Mat or Vec.\n\n    Args:\n         np_arr: The input Numpy array.\n\n    Returns:\n        A PETSc Mat or Vec, depending on the input dimension.\n\n    Raises:\n        ValueError: If the dimension of the input vector is greater than 2.\n    \"\"\"\n    n_dim = np_arr.ndim\n    if n_dim &gt; 2:\n        msg = f\"The dimension of the input array ({n_dim}) is not supported.\"\n        raise ValueError(msg)\n\n    if issparse(np_arr):\n        if not isinstance(np_arr, csr_matrix):\n            np_arr = np_arr.tocsr()\n        if n_dim == 2 and np_arr.shape[1] &gt; 1:\n            petsc_arr = PETSc.Mat().createAIJ(\n                size=np_arr.shape, csr=(np_arr.indptr, np_arr.indices, np_arr.data)\n            )\n        else:\n            petsc_arr = PETSc.Vec().createSeq(np_arr.shape[0])\n            petsc_arr.setArray(np_arr.todense())\n    else:\n        if n_dim == 1:\n            a = array(np_arr, dtype=PETSc.ScalarType)\n            petsc_arr = PETSc.Vec().createWithArray(a)\n        else:\n            petsc_arr = PETSc.Mat().createDense(np_arr.shape, array=np_arr)\n            # a_shape = np_arr.shape\n            # petsc_arr.setUp()\n            # petsc_arr.setValues(\n            #     arange(a_shape[0], dtype=\"int32\"),\n            #     arange(a_shape[1], dtype=\"int32\"),\n            #     np_arr,\n            # )\n    petsc_arr.assemble()\n    return petsc_arr\n</code></pre>"},{"location":"user_guide/","title":"User guide","text":""},{"location":"user_guide/#user-guide","title":"User guide","text":""}]}